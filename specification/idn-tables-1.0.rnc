default namespace = "http://www.iana.org/lgr/0.1"

# SIMPLE TYPES

language-tag = xsd:token  # RFC 5646 language tag (e.g. "de", "Latn", etc.)
domain-name = text        # Domain name
code-point = xsd:token {  # A single code point
    pattern = "[0-9A-F]{4,6}"
}
code-point-sequence = xsd:token { # A sequence of code points
    pattern = "[0-9A-F]{4,6}( [0-9A-F]{4,6})+"
}
code-point-literal = code-point | code-point-sequence
variant-condition = text  # A condition for applying the variant (TBD)
tag = text                # Freeform text tag
date = xsd:token {        # ISO 8601 date
    pattern = "\d{4}-\d\d-\d\d"
}
rule-ref = xsd:IDREF
tag = text
identifier = xsd:ID
class-ref = text
count-pattern = xsd:token {
    pattern = "\d+(\+|:\d+)?"
}


# STRUCTURES

## Representation of a single code point, or a sequence of code points
char = element char {
    attribute cp { code-point-literal },
    attribute comment { text }?,
    attribute when { rule-ref }?,
    attribute not-when { rule-ref }?,
    attribute tag { tag }?,
    attribute ref { text }?,
    variant*
}

## Representation of a single code point (no sequences allowed, and no tag attribute allowed)
char-single = element char {
    attribute cp { code-point },
    attribute comment { text }?,
    attribute ref { text }?,
    variant*
}

## Representation of a range of code points
range = element range {
    attribute first-cp { code-point-literal },
    attribute last-cp { code-point-literal },
    attribute comment { text }?,
    attribute tag { tag }?,
    attribute ref { text }?,
    text
}

## Representation of a variant code point or sequence
variant = element var {
    attribute cp { code-point-literal },
    attribute type { text }?,
    attribute when { rule-ref }?,
    attribute not-when { rule-ref }?,
    attribute comment { text }?,
    attribute disp { text }?,
    attribute ref { text }?
}

#
# Classes
#

## a "class" element that references the name of another "class"
## (or set-operator like "union") defined elsewhere.
## This could also be used as a matcher (appearing under a "rule"
## element), ## in which case the "count" attribute may be present.
class-invocation = element class {
    attribute byref { class-ref },
    attribute count { count-pattern }?,
    attribute comment { text }?
}

## defines a new class (set of code points) using Unicode property or
## code point literals
class-declaration = element class {
    # "name" attribute should be present if this is a "top-level" class
    # declaration, i.e. appearing directly under the "rules" element.
    # Otherwise, it should be absent.
    attribute name { identifier }?,
    attribute comment { text }?,
    (
      # define the class by property, OR
      attribute property { text }
      # list of single code points and ranges, OR
      | (char-single | range)+
      # free form text node to allow for shorthand notation e.g. "0061 0062-0063"
      | text
    )
  }

class-or-set-operator-nested = class-invocation | class-declaration | set-operator
class-or-set-operator-declaration = class-declaration | set-operator

complement-operator = element complement {
    attribute name { identifier }?,
    attribute comment { text }?,
    # "count" attribute should only be used when this set-operator is
    # used as a matcher (i.e. directly within a <rule> element)
    attribute count { count-pattern }?,
    class-or-set-operator-nested
}

union-operator = element union {
    attribute name { identifier }?,
    attribute comment { text }?,
    # "count" attribute should only be used when this set-operator is
    # used as a matcher (i.e. directly within a <rule> element)
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    # needs two or more child elements
    class-or-set-operator-nested+
}

intersection-operator = element intersection {
    attribute name { identifier }?,
    attribute comment { text }?,
    # "count" attribute should only be used when this set-operator is
    # used as a matcher (i.e. directly within a <rule> element)
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

difference-operator = element difference {
    attribute name { identifier }?,
    attribute comment { text }?,
    # "count" attribute should only be used when this set-operator is
    # used as a matcher (i.e. directly within a <rule> element)
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

symmetric-difference-operator = element symmetric-difference {
    attribute name { identifier }?,
    attribute comment { text }?,
    # "count" attribute should only be used when this set-operator is
    # used as a matcher (i.e. directly within a <rule> element)
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

## operators that transform class(es) into a new class.
set-operator = complement-operator | union-operator | intersection-operator
               | difference-operator | symmetric-difference-operator

#
# Match operators (matchers)
#

any-matcher = element any {
    attribute count { count-pattern }?
}

choice-matcher = element choice {
    attribute count { count-pattern }?,
    # two or more match operators
    match-operator,
    match-operator+
}


char-matcher = element char {
    attribute cp { code-point-literal },
    attribute comment { text }?,
    attribute ref { text }?
}

start-matcher = element start { empty }
end-matcher = element end { empty }
anchor-matcher = element anchor { empty }
look-ahead-matcher = element look-ahead { empty }
look-behind-matcher = element look-behind { empty }

match-operator = (
  any-matcher | choice-matcher | start-matcher | end-matcher | char-matcher
  | class-or-set-operator-nested | rule-matcher | anchor-matcher
  | look-ahead-matcher | look-behind-matcher
)


#
# Rules
#

# top-level rule must have "name" attribute
rule-declaration-top = element rule {
    attribute name { identifier },
    attribute comment { text }?,
    match-operator+
}

## rule element used as a matcher (either byref or contains other match operators itself)
rule-matcher =
  element rule {
    attribute count { count-pattern }?,
    attribute comment { text }?,
    (attribute byref { rule-ref } | match-operator+)
  }


#
# Actions
#

action-declaration = element action {
    attribute comment { text }?,
    attribute disp { text },
    ( attribute match { text } | attribute not-match { text } )?,
    ( attribute any-variant { text } | attribute all-variants { text } | attribute only-variants { text } )?
}


# DOCUMENT STRUCTURE

start = lgr
lgr = element lgr {
    attribute id { text }?,
    meta-section?,
    data-section,
    rules-section?
}

## Meta section - information recorded with an label
## generation ruleset that generally does not affect machine processing
## (except for unicode-version).

meta-section = element meta {
    (
        element version {
            attribute comment { text }?,
            text
        }
        | element date { date }?
        | element language { language-tag }*
        | element domain { domain-name }*
        | element validity-start { text }?
        | element validity-end { text }?
        | element unicode-version { text }*
        | element description {
             attribute type { text }?,
             text
          }*
        | element references {
            element reference {
                attribute id { text },
                attribute comment { text }?,
                text
            }*
          }?
    )*
}

# Data section - the actual code point data of the table.

data-section = element data { (char | range)+ }

# Rules section

rules-section = element rules {
    (class-or-set-operator-declaration | rule-declaration-top | action-declaration)*
}
