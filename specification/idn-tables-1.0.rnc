default namespace = "http://www.iana.org/lgr/0.1"

# SIMPLE TYPES

language-tag = xsd:token
domain-name = text
code-point = xsd:token {
    pattern = "[0-9A-F]{4,6}"
}
code-point-sequence = xsd:token {
    pattern = "[0-9A-F]{4,6}( [0-9A-F]{4,6})+"
}
code-point-literal = code-point | code-point-sequence
variant-condition = text
tag = text
date = xsd:token {
    pattern = "\d{4}-\d\d-\d\d"
}
rule-ref = xsd:IDREF
tag = text
identifier = xsd:ID
class-ref = text
count-pattern = xsd:token {
    pattern = "\d+(\+|:\d+)?"
}


# STRUCTURES

char = element char {
    attribute cp { code-point-literal },
    attribute comment { text }?,
    attribute when { rule-ref }?,
    attribute not-when { rule-ref }?,
    attribute tag { tag }?,
    attribute ref { text }?,
    variant*
}

char-single = element char {
    attribute cp { code-point },
    attribute comment { text }?,
    attribute ref { text }?,
    variant*
}

range = element range {
    attribute first-cp { code-point-literal },
    attribute last-cp { code-point-literal },
    attribute comment { text }?,
    attribute tag { tag }?,
    attribute ref { text }?,
    text
}

variant = element var {
    attribute cp { code-point-literal },
    attribute type { text }?,
    attribute when { rule-ref }?,
    attribute not-when { rule-ref }?,
    attribute comment { text }?,
    attribute disp { text }?,
    attribute ref { text }?
}

# Classes

class-invocation = element class {
    attribute byref { class-ref },
    attribute count { count-pattern }?,
    attribute comment { text }?
}

class-declaration = element class {
    attribute name { identifier }?,
    attribute comment { text }?,
    (
      attribute property { text }
      | (char-single | range)+
      | text
    )
  }

class-or-set-operator-nested = class-invocation | class-declaration | set-operator
class-or-set-operator-declaration = class-declaration | set-operator

complement-operator = element complement {
    attribute name { identifier }?,
    attribute comment { text }?,
    attribute count { count-pattern }?,
    class-or-set-operator-nested
}

union-operator = element union {
    attribute name { identifier }?,
    attribute comment { text }?,
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested+
}

intersection-operator = element intersection {
    attribute name { identifier }?,
    attribute comment { text }?,
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

difference-operator = element difference {
    attribute name { identifier }?,
    attribute comment { text }?,
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

symmetric-difference-operator = element symmetric-difference {
    attribute name { identifier }?,
    attribute comment { text }?,
    attribute count { count-pattern }?,
    class-or-set-operator-nested,
    class-or-set-operator-nested
}

set-operator = complement-operator | union-operator | intersection-operator
               | difference-operator | symmetric-difference-operator

any-matcher = element any {
    attribute count { count-pattern }?
}

choice-matcher = element choice {
    attribute count { count-pattern }?,
    # two or more match operators
    match-operator,
    match-operator+
}


char-matcher = element char {
    attribute cp { code-point-literal },
    attribute comment { text }?,
    attribute ref { text }?
}

start-matcher = element start { empty }
end-matcher = element end { empty }
anchor-matcher = element anchor { empty }
look-ahead-matcher = element look-ahead { empty }
look-behind-matcher = element look-behind { empty }

match-operator = (
  any-matcher | choice-matcher | start-matcher | end-matcher | char-matcher
  | class-or-set-operator-nested | rule-matcher | anchor-matcher
  | look-ahead-matcher | look-behind-matcher
)


#
# Rules
#

rule-declaration-top = element rule {
    attribute name { identifier },
    attribute comment { text }?,
    match-operator+
}

rule-matcher =
  element rule {
    attribute count { count-pattern }?,
    attribute comment { text }?,
    (attribute byref { rule-ref } | match-operator+)
  }


#
# Actions
#

action-declaration = element action {
    attribute comment { text }?,
    attribute disp { text },
    ( attribute match { text } | attribute not-match { text } )?,
    ( attribute any-variant { text } | attribute all-variants { text } | attribute only-variants { text } )?
}

# DOCUMENT STRUCTURE

start = lgr
lgr = element lgr {
    attribute id { text }?,
    meta-section?,
    data-section,
    rules-section?
}

meta-section = element meta {
    (
        element version {
            attribute comment { text }?,
            text
        }
        | element date { date }?
        | element language { language-tag }*
        | element domain { domain-name }*
        | element validity-start { text }?
        | element validity-end { text }?
        | element unicode-version { text }*
        | element description {
             attribute type { text }?,
             text
          }*
        | element references {
            element reference {
                attribute id { text },
                attribute comment { text }?,
                text
            }*
          }?
    )*
}

data-section = element data { (char | range)+ }

rules-section = element rules {
    (class-or-set-operator-declaration | rule-declaration-top | action-declaration)*
}
