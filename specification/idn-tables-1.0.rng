<?xml version="1.0" encoding="UTF-8"?>
<!--
  
  LGR XML Schema 1.0 (internal version 0.5a - based on draft-davies-idntables-06)
  
-->
<grammar ns="http://www.iana.org/lgr/0.1" xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!--
    
    SIMPLE TYPES
    
  -->
  <!-- RFC 5646 language tag (e.g. "de", "Latn", etc.) -->
  <define name="language-tag">
    <data type="token"/>
  </define>
  <define name="domain-name">
    <a:documentation>domain to which this LGR applies</a:documentation>
    <text/>
  </define>
  <define name="code-point">
    <a:documentation>a single code point</a:documentation>
    <data type="token">
      <param name="pattern">[0-9A-F]{4,6}</param>
    </data>
  </define>
  <define name="code-point-sequence">
    <a:documentation>a space-separated sequence of code points</a:documentation>
    <data type="token">
      <param name="pattern">[0-9A-F]{4,6}( [0-9A-F]{4,6})+</param>
    </data>
  </define>
  <define name="code-point-literal">
    <a:documentation>single code point, or a sequence of code points</a:documentation>
    <choice>
      <ref name="code-point"/>
      <ref name="code-point-sequence"/>
    </choice>
  </define>
  <define name="code-point-set-shorthand">
    <data type="token">
      <param name="pattern">([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6})( ([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6}))*</param>
    </data>
  </define>
  <define name="date">
    <a:documentation>dates are used in information fields in the meta section.</a:documentation>
    <data type="token">
      <param name="pattern">\d{4}-\d\d-\d\d</param>
    </data>
  </define>
  <define name="rule-ref">
    <a:documentation>reference to a rule name (used in "when" and "not-when" attributes, as well
as the "by-ref" attribute of the "rule" element.)</a:documentation>
    <data type="IDREF"/>
  </define>
  <define name="tags">
    <a:documentation>a space-separated list of tags. Tags should generally follow identifier
syntax, although the use of punctuation symbols such as a colon is allowed.</a:documentation>
    <text/>
  </define>
  <define name="tag-ref">
    <a:documentation>Although "from-tag" attributes are closer to xsd:IDREF lexically and
semantically, tags do not appear as a single unique instance in the
document. As such, we are unable to take advantage of facilities provided
by the validator.</a:documentation>
    <text/>
  </define>
  <define name="identifier">
    <a:documentation>an identifier type (used by "name" attributes).</a:documentation>
    <data type="ID"/>
  </define>
  <define name="class-ref">
    <a:documentation>used in the class "by-ref" attribute to reference another class of the same
"name" attribute value.</a:documentation>
    <data type="IDREF"/>
  </define>
  <define name="count-pattern">
    <a:documentation>count attribute pattern ("n", "n+" or "n:m")</a:documentation>
    <data type="token">
      <param name="pattern">\d+(\+|:\d+)?</param>
    </data>
  </define>
  <!--
    
    STRUCTURES
    
  -->
  <define name="char">
    <a:documentation>Representation of a single code point, or a sequence of code points</a:documentation>
    <element name="char">
      <attribute name="cp">
        <ref name="code-point-literal"/>
      </attribute>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="when">
          <ref name="rule-ref"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="not-when">
          <ref name="rule-ref"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="tag">
          <ref name="tags"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <zeroOrMore>
        <ref name="variant"/>
      </zeroOrMore>
    </element>
  </define>
  <define name="range">
    <a:documentation>Representation of a range of code points</a:documentation>
    <element name="range">
      <attribute name="first-cp">
        <ref name="code-point"/>
      </attribute>
      <attribute name="last-cp">
        <ref name="code-point"/>
      </attribute>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="tag">
          <ref name="tags"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
    </element>
  </define>
  <define name="char-simple">
    <a:documentation>Representation of a single code point (no sequences allowed, and no tag attribute allowed).
This is used when defining the set of characters that constitute a class.</a:documentation>
    <element name="char">
      <attribute name="cp">
        <ref name="code-point"/>
      </attribute>
    </element>
  </define>
  <define name="range-simple">
    <a:documentation>Representation of a range of code points, for use in defining the set of
characters that constitute a class.</a:documentation>
    <element name="range">
      <attribute name="first-cp">
        <ref name="code-point"/>
      </attribute>
      <attribute name="last-cp">
        <ref name="code-point"/>
      </attribute>
    </element>
  </define>
  <define name="variant">
    <a:documentation>Representation of a variant code point or sequence</a:documentation>
    <element name="var">
      <attribute name="cp">
        <ref name="code-point-literal"/>
      </attribute>
      <optional>
        <attribute name="type"/>
      </optional>
      <optional>
        <attribute name="when">
          <ref name="rule-ref"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="not-when">
          <ref name="rule-ref"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="disp"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
    </element>
  </define>
  <!--
    
    Classes
    
  -->
  <define name="class-invocation">
    <a:documentation>a "class" element that references the name of another "class"
(or set-operator like "union") defined elsewhere.
If used as a matcher (appearing under a "rule" ## element),
the "count" attribute may be present.</a:documentation>
    <element name="class">
      <choice>
        <attribute name="by-ref">
          <ref name="class-ref"/>
        </attribute>
        <attribute name="from-tag">
          <ref name="tag-ref"/>
        </attribute>
      </choice>
      <optional>
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
    </element>
  </define>
  <define name="class-declaration">
    <a:documentation>defines a new class (set of code points) using Unicode property or
code point literals</a:documentation>
    <element name="class">
      <optional>
        <!--
          "name" attribute MUST be present if this is a "top-level" class
          declaration, i.e. appearing directly under the "rules" element.
          Otherwise, it MUST be absent.
        -->
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <!--
          If used as a matcher (appearing in a "rule" element), the "count"
          attribute may be present. Otherwise, it MUST be absent.
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <choice>
        <!-- define the class by property (e.g. property="sc:Latn"), OR -->
        <attribute name="property"/>
        <!-- define the class by tagged code points, OR -->
        <attribute name="from-tag">
          <ref name="tag-ref"/>
        </attribute>
        <oneOrMore>
          <!-- list of single code points and ranges, OR -->
          <choice>
            <ref name="char-simple"/>
            <ref name="range-simple"/>
          </choice>
        </oneOrMore>
        <!-- text node to allow for shorthand notation e.g. "0061 0062-0063" -->
        <ref name="code-point-set-shorthand"/>
      </choice>
    </element>
  </define>
  <define name="class-or-set-operator-nested">
    <choice>
      <ref name="class-invocation"/>
      <ref name="class-declaration"/>
      <ref name="set-operator"/>
    </choice>
  </define>
  <define name="class-or-set-operator-declaration">
    <choice>
      <!--
        a "class" element or set operator (effectively defining a class)
        directly in the "rules" element.
      -->
      <ref name="class-declaration"/>
      <ref name="set-operator"/>
    </choice>
  </define>
  <!--
    
    Set operators
    
  -->
  <define name="complement-operator">
    <element name="complement">
      <optional>
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <optional>
        <!--
          "count" attribute MUST only be used when this set-operator is
          used as a matcher (i.e. nested in a <rule> element)
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <ref name="class-or-set-operator-nested"/>
    </element>
  </define>
  <define name="union-operator">
    <element name="union">
      <optional>
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <optional>
        <!--
          "count" attribute MUST only be used when this set-operator is
          used as a matcher (i.e. nested in a <rule> element)
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <ref name="class-or-set-operator-nested"/>
      <oneOrMore>
        <!-- needs two or more child elements -->
        <ref name="class-or-set-operator-nested"/>
      </oneOrMore>
    </element>
  </define>
  <define name="intersection-operator">
    <element name="intersection">
      <optional>
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <optional>
        <!--
          "count" attribute MUST only be used when this set-operator is
          used as a matcher (i.e. nested in a <rule> element)
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <ref name="class-or-set-operator-nested"/>
      <ref name="class-or-set-operator-nested"/>
    </element>
  </define>
  <define name="difference-operator">
    <element name="difference">
      <optional>
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <optional>
        <!--
          "count" attribute MUST only be used when this set-operator is
          used as a matcher (i.e. nested in a <rule> element)
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <ref name="class-or-set-operator-nested"/>
      <ref name="class-or-set-operator-nested"/>
    </element>
  </define>
  <define name="symmetric-difference-operator">
    <element name="symmetric-difference">
      <optional>
        <attribute name="name">
          <ref name="identifier"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <optional>
        <!--
          "count" attribute MUST only be used when this set-operator is
          used as a matcher (i.e. nested in a <rule> element)
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <ref name="class-or-set-operator-nested"/>
      <ref name="class-or-set-operator-nested"/>
    </element>
  </define>
  <define name="set-operator">
    <a:documentation>operators that transform class(es) into a new class.</a:documentation>
    <choice>
      <ref name="complement-operator"/>
      <ref name="union-operator"/>
      <ref name="intersection-operator"/>
      <ref name="difference-operator"/>
      <ref name="symmetric-difference-operator"/>
    </choice>
  </define>
  <!--
    
    Match operators (matchers)
    
  -->
  <define name="any-matcher">
    <element name="any">
      <optional>
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
    </element>
  </define>
  <define name="choice-matcher">
    <element name="choice">
      <optional>
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <!-- two or more match operators -->
      <ref name="match-operator-choice"/>
      <oneOrMore>
        <ref name="match-operator-choice"/>
      </oneOrMore>
    </element>
  </define>
  <define name="char-matcher">
    <!-- for use as a matcher - like "char", except without the "tag" attribute -->
    <element name="char">
      <attribute name="cp">
        <ref name="code-point-literal"/>
      </attribute>
      <optional>
        <!--
          If used as a matcher (appearing in a "rule" element), the "count"
          attribute may be present. Otherwise, it MUST be absent.
        -->
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
    </element>
  </define>
  <define name="start-matcher">
    <element name="start">
      <optional>
        <attribute name="comment"/>
      </optional>
    </element>
  </define>
  <define name="end-matcher">
    <element name="end">
      <optional>
        <attribute name="comment"/>
      </optional>
    </element>
  </define>
  <define name="anchor-matcher">
    <element name="anchor">
      <optional>
        <attribute name="comment"/>
      </optional>
    </element>
  </define>
  <define name="look-ahead-matcher">
    <element name="look-ahead">
      <optional>
        <attribute name="comment"/>
      </optional>
      <ref name="match-operators-non-pos"/>
    </element>
  </define>
  <define name="look-behind-matcher">
    <element name="look-behind">
      <optional>
        <attribute name="comment"/>
      </optional>
      <ref name="match-operators-non-pos"/>
    </element>
  </define>
  <define name="match-operator-choice">
    <a:documentation>non-positional match operator that can be used as a direct child element
of the choice matcher.</a:documentation>
    <choice>
      <ref name="any-matcher"/>
      <ref name="choice-matcher"/>
      <ref name="start-matcher"/>
      <ref name="end-matcher"/>
      <ref name="char-matcher"/>
      <ref name="class-or-set-operator-nested"/>
      <ref name="rule-matcher"/>
    </choice>
  </define>
  <define name="match-operators-non-pos">
    <a:documentation>non-positional match operators do not contain any anchor, 
look-behind or look-ahead elements.</a:documentation>
    <optional>
      <ref name="start-matcher"/>
    </optional>
    <zeroOrMore>
      <choice>
        <ref name="any-matcher"/>
        <ref name="choice-matcher"/>
        <ref name="char-matcher"/>
        <ref name="class-or-set-operator-nested"/>
        <ref name="rule-matcher"/>
      </choice>
    </zeroOrMore>
    <optional>
      <ref name="end-matcher"/>
    </optional>
  </define>
  <define name="match-operators-pos">
    <a:documentation>positional match operators have an anchor element, which may be preceeded by
a look-behind element, or followed by a look-ahead element, or both.</a:documentation>
    <optional>
      <ref name="look-behind-matcher"/>
    </optional>
    <ref name="anchor-matcher"/>
    <optional>
      <ref name="look-ahead-matcher"/>
    </optional>
  </define>
  <define name="match-operators">
    <choice>
      <ref name="match-operators-non-pos"/>
      <ref name="match-operators-pos"/>
    </choice>
  </define>
  <!--
    
    Rules
    
  -->
  <!-- top-level rule must have "name" attribute -->
  <define name="rule-declaration-top">
    <element name="rule">
      <attribute name="name">
        <ref name="identifier"/>
      </attribute>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <ref name="match-operators"/>
    </element>
  </define>
  <define name="rule-matcher">
    <a:documentation>rule element used as a matcher (either by-ref or contains other match operators itself)</a:documentation>
    <element name="rule">
      <optional>
        <attribute name="count">
          <ref name="count-pattern"/>
        </attribute>
      </optional>
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <choice>
        <attribute name="by-ref">
          <ref name="rule-ref"/>
        </attribute>
        <ref name="match-operators"/>
      </choice>
    </element>
  </define>
  <!--
    
    Actions
    
  -->
  <define name="action-declaration">
    <element name="action">
      <optional>
        <attribute name="comment"/>
      </optional>
      <optional>
        <attribute name="ref"/>
      </optional>
      <attribute name="disp"/>
      <optional>
        <choice>
          <attribute name="match"/>
          <attribute name="not-match"/>
        </choice>
      </optional>
      <optional>
        <choice>
          <attribute name="any-variant"/>
          <attribute name="all-variants"/>
          <attribute name="only-variants"/>
        </choice>
      </optional>
    </element>
  </define>
  <!-- DOCUMENT STRUCTURE -->
  <start>
    <ref name="lgr"/>
  </start>
  <define name="lgr">
    <element name="lgr">
      <optional>
        <attribute name="id"/>
      </optional>
      <optional>
        <ref name="meta-section"/>
      </optional>
      <ref name="data-section"/>
      <optional>
        <ref name="rules-section"/>
      </optional>
    </element>
  </define>
  <define name="meta-section">
    <a:documentation>Meta section - information recorded with an label
generation ruleset that generally does not affect machine processing
(except for unicode-version).
However, if any "class-declaration" uses the "property" attribute,
one or more unicode-version MUST be present.</a:documentation>
    <element name="meta">
      <interleave>
        <optional>
          <element name="version">
            <optional>
              <attribute name="comment"/>
            </optional>
            <text/>
          </element>
        </optional>
        <optional>
          <element name="date">
            <data type="token">
              <param name="pattern">\d{4}-\d{2}-\d{2}</param>
            </data>
          </element>
        </optional>
        <zeroOrMore>
          <element name="language">
            <ref name="language-tag"/>
          </element>
        </zeroOrMore>
        <zeroOrMore>
          <element name="domain">
            <ref name="domain-name"/>
          </element>
        </zeroOrMore>
        <optional>
          <element name="validity-start">
            <text/>
          </element>
        </optional>
        <optional>
          <element name="validity-end">
            <text/>
          </element>
        </optional>
        <optional>
          <element name="unicode-version">
            <data type="token">
              <param name="pattern">\d+\.\d+\.\d+</param>
            </data>
          </element>
        </optional>
        <optional>
          <element name="description">
            <optional>
              <attribute name="type"/>
            </optional>
            <text/>
          </element>
        </optional>
        <optional>
          <element name="references">
            <zeroOrMore>
              <element name="reference">
                <attribute name="id"/>
                <optional>
                  <attribute name="comment"/>
                </optional>
                <text/>
              </element>
            </zeroOrMore>
          </element>
        </optional>
      </interleave>
    </element>
  </define>
  <define name="data-section">
    <element name="data">
      <oneOrMore>
        <choice>
          <ref name="char"/>
          <ref name="range"/>
        </choice>
      </oneOrMore>
    </element>
  </define>
  <define name="rules-section">
    <a:documentation>Note that action declarations are strictly order dependent.
class-or-set-operator-declaration and rule-declaration-top
are weakly order dependent, they must precede first use of the
identifier via by-ref.</a:documentation>
    <element name="rules">
      <zeroOrMore>
        <choice>
          <ref name="class-or-set-operator-declaration"/>
          <ref name="rule-declaration-top"/>
          <ref name="action-declaration"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
</grammar>
